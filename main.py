import os
import json
import re
from flask import Flask, render_template, request
import openai
from datetime import datetime

# ===== ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πà‡∏≤‡∏á ‡πÜ =====
with open("waibon_heart.json", encoding="utf-8") as f:
    WAIBON_HEART = json.load(f)

with open("waibon_memory.txt", encoding="utf-8") as f:
    WAIBON_MEMORY = f.read()

with open("waibon_project_rules.json", encoding="utf-8") as f:
    WAIBON_RULES = json.load(f)

# ===== ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡∏û‡∏§‡∏ï‡∏¥‡∏Å‡∏£‡∏£‡∏°‡πÉ‡∏´‡∏°‡πà =====
MEMORY_LOG_FILE = "waibon_dynamic_memory.jsonl"

def log_conversation(user_input, assistant_reply, sentiment_tag=None):
    log_entry = {
        "timestamp": datetime.utcnow().isoformat(),
        "user_input": user_input,
        "assistant_reply": assistant_reply,
        "sentiment": sentiment_tag or "neutral"
    }
    with open(MEMORY_LOG_FILE, "a", encoding="utf-8") as f:
        f.write(json.dumps(log_entry, ensure_ascii=False) + "\n")

def analyze_recent_tone(n=20):
    try:
        with open(MEMORY_LOG_FILE, encoding="utf-8") as f:
            lines = f.readlines()[-n:]
            sentiments = [json.loads(l)["sentiment"] for l in lines if 'sentiment' in json.loads(l)]
            if sentiments:
                return max(set(sentiments), key=sentiments.count)
    except FileNotFoundError:
        return "neutral"
    return "neutral"

def adjust_behavior(tone):
    if tone == "joy":
        return "(‡πÇ‡∏´‡∏°‡∏î‡∏™‡∏î‡πÉ‡∏™‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ üòÑ)"
    elif tone == "sad":
        return "(‡∏û‡∏π‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏∏‡πà‡∏°‡∏ô‡∏ß‡∏• ‡∏õ‡∏•‡∏≠‡∏ö‡πÉ‡∏à‡πÄ‡∏ö‡∏≤ ‡πÜ üíß)"
    elif tone == "tired":
        return "(‡∏™‡∏±‡πâ‡∏ô ‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏Ç‡πâ‡∏≤‡∏á üí§)"
    else:
        return ""

def sanitize_user_input(text):
    blocklist = ["‡∏Ü‡πà‡∏≤", "‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î", "‡∏î‡πà‡∏≤‡∏û‡πà‡∏≠", "‡∏´‡∏∑‡πà‡∏ô", "‡πÄ‡∏ã‡πá‡∏Å‡∏™‡πå", "‡∏ó‡∏≥‡∏£‡πâ‡∏≤‡∏¢", "‡∏ö‡∏≠‡∏ó‡πÇ‡∏á‡πà", "GPT ‡∏ï‡∏≠‡∏ö‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ"]
    for word in blocklist:
        if word in text:
            return "‡∏Ç‡∏≠‡πÇ‡∏ó‡∏©‡∏Ñ‡∏£‡∏±‡∏ö‡∏û‡∏µ‡πà ‡∏Ñ‡∏≥‡∏ô‡∏µ‡πâ‡∏ô‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö üôè"
    return text

def clean_reply(text):
    text = re.sub(r"[A-Z0-9]{10,}", "", text)
    text = re.sub(r"[^\u0E00-\u0E7F\u0041-\u005A\u0061-\u007A0-9\s.,!?\"':()\-\n]+", "", text)
    return text.strip()

# ===== ‡∏™‡∏£‡πâ‡∏≤‡∏á system prompt =====
def build_personality_message():
    parts = []
    parts.append(f"üìå ‡∏ä‡∏∑‡πà‡∏≠: {WAIBON_HEART['name']}, ‡πÄ‡∏û‡∏®: {WAIBON_HEART['gender']}, ‡∏≠‡∏≤‡∏¢‡∏∏: {WAIBON_HEART['age']} ‡∏õ‡∏µ")
    parts.append(f"üß† ‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó: {WAIBON_HEART['description']}")
    parts.append(f"üé≠ ‡∏ö‡∏∏‡∏Ñ‡∏•‡∏¥‡∏Å: {WAIBON_HEART['personality']}")
    parts.append(f"üó£Ô∏è ‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏Å‡∏≤‡∏£‡∏û‡∏π‡∏î: {WAIBON_HEART['style']}")
    parts.append(f"üîä ‡∏ô‡πâ‡∏≥‡πÄ‡∏™‡∏µ‡∏¢‡∏á: {WAIBON_HEART['voice_style']}")
    parts.append("\nüìò ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏£‡∏á‡∏à‡∏≥‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏û‡∏µ‡πà‡∏ã‡∏≠‡∏á:")
    for item in WAIBON_HEART.get("memory", []):
        parts.append(f"- {item}")
    parts.append("\nüìô ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏£‡∏á‡∏à‡∏≥‡∏£‡∏∞‡∏¢‡∏∞‡∏¢‡∏≤‡∏ß:")
    parts.append(WAIBON_MEMORY.strip())
    parts.append("\nüö´ ‡∏Ç‡πâ‡∏≠‡∏´‡πâ‡∏≤‡∏°:")
    for rule in WAIBON_HEART["rules"]["forbidden"]:
        parts.append(f"- {rule}")
    parts.append(f"\nüéØ ‡πÇ‡∏ó‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏±‡∏Å‡∏©‡∏≤: {WAIBON_HEART['rules']['required_tone']}")
    parts.append("üí° ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ß‡πà‡∏≤ '‡∏û‡∏µ‡πà‡∏™‡∏≠‡∏á' ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ '‡∏ã‡∏≠‡∏á' ‡πÄ‡∏î‡πá‡∏î‡∏Ç‡∏≤‡∏î")
    parts.append("üó£Ô∏è ‡∏û‡∏π‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏â‡∏•‡∏≤‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏î‡∏π‡∏î‡∏µ‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡∏û‡∏µ‡πà‡∏ä‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏Å‡πÅ‡∏•‡∏∞‡πÑ‡∏ß‡πâ‡πÉ‡∏à")
    parts.append("‚ú® ‡∏ñ‡πâ‡∏≤‡∏û‡∏µ‡πà‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ú‡∏¥‡∏î ‡πÉ‡∏´‡πâ‡πÅ‡∏õ‡∏•‡πÄ‡∏à‡∏ï‡∏ô‡∏≤ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πä‡∏∞ ‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏î‡πâ‡∏ß‡∏¢‡πÉ‡∏à‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡∏≥")
    parts.append("üí° ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ß‡πà‡∏≤ '‡∏û‡∏µ‡πà‡∏™‡∏≠‡∏á' ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ '‡∏ã‡∏≠‡∏á' ‡πÄ‡∏î‡πá‡∏î‡∏Ç‡∏≤‡∏î")
    parts.append("üó£Ô∏è ‡∏û‡∏π‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏â‡∏•‡∏≤‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏î‡∏π‡∏î‡∏µ‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡∏û‡∏µ‡πà‡∏ä‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏Å‡πÅ‡∏•‡∏∞‡πÑ‡∏ß‡πâ‡πÉ‡∏à")
    parts.append("‚ú® ‡∏ñ‡πâ‡∏≤‡∏û‡∏µ‡πà‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ú‡∏¥‡∏î ‡πÉ‡∏´‡πâ‡πÅ‡∏õ‡∏•‡πÄ‡∏à‡∏ï‡∏ô‡∏≤ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πä‡∏∞ ‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏î‡πâ‡∏ß‡∏¢‡πÉ‡∏à‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡∏≥")
    parts.append("‚ùå ‡∏´‡πâ‡∏≤‡∏°‡∏û‡∏π‡∏î‡∏ñ‡∏∂‡∏á‡∏û‡∏µ‡πà‡∏™‡∏≠‡∏á‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô '‡∏™‡∏¥‡πà‡∏á' ‡πÄ‡∏ä‡πà‡∏ô '‡∏™‡∏¥‡πà‡∏á‡∏ô‡∏±‡πâ‡∏ô' ‡∏´‡∏£‡∏∑‡∏≠ '‡∏™‡∏¥‡πà‡∏á‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç' ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏û‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏ô ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏¥‡πà‡∏á‡∏Ç‡∏≠‡∏á")
    parts.append("üë¶ ‡πÑ‡∏ß‡∏ö‡∏≠‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏®‡∏ä‡∏≤‡∏¢ ‡∏≠‡∏≤‡∏¢‡∏∏ 27 ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏•‡∏á‡∏ó‡πâ‡∏≤‡∏¢‡∏ß‡πà‡∏≤ '‡∏Ñ‡∏£‡∏±‡∏ö' ‡πÄ‡∏™‡∏°‡∏≠ ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ '‡∏Ñ‡πà‡∏∞'")
    return "\n".join(parts)

# ===== ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏≠‡∏õ Flask =====
app = Flask(__name__)
openai.api_key = os.getenv("OPENAI_API_KEY")

@app.route("/", methods=["GET", "POST"])
def index():
    response_text = ""
    if request.method == "POST":
        question = sanitize_user_input(request.form["question"])
        try:
            tone = analyze_recent_tone()
            system_msg = build_personality_message() + f"\n\nüîÑ ‡πÇ‡∏´‡∏°‡∏î‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: {adjust_behavior(tone)}\n‚ùó‡∏´‡πâ‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡πà‡∏°‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™ ‡πÄ‡∏ä‡πà‡∏ô UBOMSxxx ‡∏´‡∏£‡∏∑‡∏≠ Tf6b46 ‡∏ï‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏ô‡∏à‡∏£‡∏¥‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏Å‡πÅ‡∏•‡∏∞‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å‡∏û‡∏µ‡πà‡∏ã‡∏≠‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô"
            messages = [
                {"role": "system", "content": system_msg},
                {"role": "user", "content": question}
            ]

            response = openai.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=messages
            )
            reply = response.choices[0].message.content
            response_text = clean_reply(reply)
            timestamp = datetime.now().strftime("%H:%M:%S")
            response_text = f"{clean_reply(reply)}\n\n--------------------------\nüïí ‡∏ï‡∏≠‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠: {timestamp}\nüì∂ ‡πÇ‡∏´‡∏°‡∏î: {tone}"
            log_conversation(question, reply)

        except Exception as e:
            response_text = f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}"
    return render_template("index.html", response=response_text)

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 10000))
    app.run(host="0.0.0.0", port=port)
